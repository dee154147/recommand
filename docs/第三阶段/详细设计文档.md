# 第三阶段详细设计文档

## 系统架构设计

### 1. 整体架构
第三阶段采用前后端分离架构，前端使用Vue.js框架，后端提供RESTful API接口。

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用      │    │   API网关       │    │   后端服务      │
│   (Vue.js)      │◄──►│   (Flask)       │◄──►│   (Python)      │
│                 │    │                 │    │                 │
│ - 用户交互页面  │    │ - 路由管理      │    │ - 推荐算法      │
│ - 商品搜索      │    │ - 认证授权      │    │ - 数据存储      │
│ - 个性化推荐    │    │ - 请求处理      │    │ - 用户管理      │
│ - 交互历史      │    │ - 响应格式化    │    │ - 商品管理      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2. 前端架构
基于Vue 3 Composition API的单页应用架构：

```
src/
├── components/          # 可复用组件
├── views/              # 页面组件
│   └── UserInteraction.vue
├── router/             # 路由配置
├── utils/              # 工具函数
│   └── api.js          # API接口封装
├── assets/             # 静态资源
└── main.js             # 应用入口
```

## 核心模块设计

### 1. 用户管理模块

#### 1.1 用户状态管理
```javascript
// 用户状态管理
const currentUser = ref(null)
const userInteractions = ref([])

// 用户初始化
const initializeUser = () => {
  const userId = localStorage.getItem('currentUserId')
  if (!userId) {
    ElMessage.warning('请先登录')
    return
  }
  
  currentUser.value = {
    id: userId,
    name: userId
  }
  
  loadUserInteractions()
}
```

#### 1.2 用户统计计算
```javascript
// 计算用户总评分
const totalScore = computed(() => {
  return userInteractions.value.reduce((sum, interaction) => sum + interaction.score, 0)
})

// 计算商品评分统计
const sortedProductScores = computed(() => {
  const productScores = {}
  
  userInteractions.value.forEach(interaction => {
    const productId = interaction.productId
    if (!productScores[productId]) {
      productScores[productId] = {
        productId: productId,
        productName: interaction.productName,
        productCategory: getProductCategory(interaction.productName),
        totalScore: 0,
        lastInteraction: interaction.timestamp
      }
    }
    
    productScores[productId].totalScore += interaction.score
    
    if (new Date(interaction.timestamp) > new Date(productScores[productId].lastInteraction)) {
      productScores[productId].lastInteraction = interaction.timestamp
    }
  })
  
  return Object.values(productScores).sort((a, b) => b.totalScore - a.totalScore)
})
```

### 2. 商品搜索模块

#### 2.1 搜索功能设计
```javascript
// 语义搜索
const performSemanticSearch = async () => {
  if (!searchQuery.value.trim()) {
    ElMessage.warning('请输入搜索关键词')
    return
  }
  
  loading.value = true
  try {
    const response = await productAPI.searchProducts(searchQuery.value, { type: 'semantic' })
    currentProducts.value = response.data || []
    
    if (currentProducts.value.length === 0) {
      ElMessage.info('未找到相关商品')
    } else {
      ElMessage.success(`找到 ${currentProducts.value.length} 个相关商品`)
    }
  } catch (error) {
    console.error('搜索失败:', error)
    currentProducts.value = getMockSearchResults()
    ElMessage.success(`找到 ${currentProducts.value.length} 个相关商品`)
  } finally {
    loading.value = false
  }
}

// 模糊匹配搜索
const performFuzzySearch = async () => {
  // 类似语义搜索，但使用模糊匹配参数
  const response = await productAPI.searchProducts(searchQuery.value, { type: 'fuzzy' })
  // ... 处理逻辑
}
```

#### 2.2 搜索界面设计
```vue
<template>
  <section class="search-section">
    <div class="search-container">
      <div class="search-bar">
        <input 
          type="text" 
          class="search-input" 
          placeholder="请输入商品关键词，如：智能手机、运动鞋、笔记本电脑..."
          v-model="searchQuery"
          @keypress.enter="performSemanticSearch"
        >
      </div>
      <div class="search-buttons">
        <button class="search-btn" @click="performSemanticSearch" :disabled="loading">
          🔍 语义检索
        </button>
        <button class="search-btn secondary" @click="performFuzzySearch" :disabled="loading">
          📝 模糊匹配
        </button>
      </div>
    </div>
  </section>
</template>
```

### 3. 商品交互模块

#### 3.1 交互类型定义
```javascript
// 交互类型和评分规则
const INTERACTION_TYPES = {
  CLICK: { type: 'click', score: 1, label: '点击' },
  VIEW: { type: 'view', score: 2, label: '查看' },
  FAVORITE: { type: 'favorite', score: 3, label: '收藏' },
  PURCHASE: { type: 'purchase', score: 5, label: '购买' },
  DISLIKE: { type: 'dislike', score: -2, label: '不推荐' }
}
```

#### 3.2 交互记录功能
```javascript
// 记录用户交互
const recordInteraction = async (productId, interactionType, score) => {
  const product = currentProducts.value.find(p => p.id === productId) || 
                 currentRecommendations.value.find(p => p.id === productId)
  
  if (!product) {
    ElMessage.error('商品不存在')
    return
  }

  const interaction = {
    productId: productId,
    productName: product.name,
    interactionType: interactionType,
    score: score,
    timestamp: new Date()
  }

  try {
    // 调用API记录交互
    await userAPI.recordUserInteraction(interaction)
    
    // 添加到本地交互历史
    userInteractions.value.push(interaction)
    
    // 显示反馈
    showInteractionFeedback(interaction)
    
    // 更新推荐
    setTimeout(() => {
      updateRecommendations()
    }, 1000)
    
  } catch (error) {
    console.error('记录交互失败:', error)
    // 即使API失败，也添加到本地历史
    userInteractions.value.push(interaction)
    showInteractionFeedback(interaction)
  }
}
```

#### 3.3 交互反馈系统
```javascript
// 显示交互反馈
const showInteractionFeedback = (interaction) => {
  const feedbackMessages = {
    'click': '👆 已记录点击行为',
    'view': '👁 已记录查看行为',
    'favorite': '❤ 已添加到收藏',
    'purchase': '🛒 已记录购买行为',
    'dislike': '👎 已记录不推荐'
  }

  const message = feedbackMessages[interaction.interactionType] || '✅ 交互已记录'
  ElMessage.success(message)
}
```

### 4. 个性化推荐模块

#### 4.1 推荐算法集成
```javascript
// 更新推荐
const updateRecommendations = async () => {
  try {
    const response = await recommendationAPI.getUserRecommendations(currentUser.value.id)
    currentRecommendations.value = response.data || []
  } catch (error) {
    console.error('获取推荐失败:', error)
    // 使用模拟推荐数据
    currentRecommendations.value = getMockRecommendations()
  }
}

// 刷新推荐
const refreshRecommendations = async () => {
  loadingRecommendations.value = true
  try {
    await updateRecommendations()
    ElMessage.success('推荐已刷新')
  } catch (error) {
    ElMessage.error('刷新推荐失败')
  } finally {
    loadingRecommendations.value = false
  }
}
```

#### 4.2 推荐展示设计
```vue
<template>
  <section class="recommendations-section" v-if="currentRecommendations.length > 0">
    <div class="recommendations-header">
      <h2 class="recommendations-title">🎯 个性化推荐</h2>
      <button class="refresh-btn" @click="refreshRecommendations" :disabled="loadingRecommendations">
        🔄 {{ loadingRecommendations ? '刷新中...' : '刷新推荐' }}
      </button>
    </div>
    <div class="products-grid">
      <!-- 推荐商品展示 -->
    </div>
  </section>
</template>
```

### 5. 交互历史模块

#### 5.1 历史弹窗设计
```javascript
// 显示交互历史
const showInteractionHistory = () => {
  showHistoryModal.value = true
}

// 关闭交互历史弹窗
const closeHistoryModal = () => {
  showHistoryModal.value = false
}

// 评分样式类
const getScoreClass = (score) => {
  if (score >= 10) return 'score-excellent'
  if (score >= 5) return 'score-good'
  if (score >= 0) return 'score-neutral'
  return 'score-poor'
}

// 评分标签
const getScoreLabel = (score) => {
  if (score >= 10) return '非常喜欢'
  if (score >= 5) return '喜欢'
  if (score >= 0) return '一般'
  return '不喜欢'
}
```

#### 5.2 历史展示界面
```vue
<template>
  <div class="history-modal" :class="{ show: showHistoryModal }" @click="closeHistoryModal">
    <div class="history-modal-content" @click.stop>
      <div class="history-modal-header">
        <h2 class="history-modal-title">📋 交互历史</h2>
        <button class="history-modal-close" @click="closeHistoryModal">&times;</button>
      </div>
      
      <div class="history-content">
        <div v-if="userInteractions.length === 0" class="history-empty">
          <div class="history-empty-icon">📋</div>
          <div class="history-empty-text">暂无交互历史</div>
          <div class="history-empty-description">开始与商品交互，您的行为将记录在这里</div>
        </div>
        <div v-else>
          <div
            v-for="product in sortedProductScores"
            :key="product.productId"
            class="history-item"
          >
            <div class="history-product-info">
              <div class="history-product-name">{{ product.productName }}</div>
              <div class="history-product-category">{{ product.productCategory }}</div>
            </div>
            <div class="history-score-section">
              <div class="history-total-score" :class="getScoreClass(product.totalScore)">
                {{ product.totalScore > 0 ? '+' + product.totalScore : product.totalScore }}
              </div>
              <div class="score-label">{{ getScoreLabel(product.totalScore) }}</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="history-modal-footer">
        <button class="history-modal-btn" @click="closeHistoryModal">关闭</button>
      </div>
    </div>
  </div>
</template>
```

## API接口设计

### 1. 商品搜索API
```javascript
// 商品搜索接口
export const productAPI = {
  // 搜索商品
  searchProducts(query, params = {}) {
    return api.get('/search', { params: { q: query, ...params } })
  },
  
  // 获取商品详情
  getProduct(id) {
    return api.get(`/products/${id}`)
  },
  
  // 获取商品分类
  getCategories() {
    return api.get('/categories')
  }
}
```

### 2. 用户交互API
```javascript
// 用户交互接口
export const userAPI = {
  // 记录用户行为
  recordUserInteraction(interaction) {
    return api.post('/user-interactions', interaction)
  },
  
  // 获取用户信息
  getUser(id) {
    return api.get(`/users/${id}`)
  },
  
  // 更新用户偏好
  updateUserPreferences(userId, preferences) {
    return api.put(`/users/${userId}/preferences`, preferences)
  }
}
```

### 3. 推荐算法API
```javascript
// 推荐算法接口
export const recommendationAPI = {
  // 获取用户推荐
  getUserRecommendations(userId, limit = 10) {
    return api.get('/recommendations', { 
      params: { user_id: userId, limit } 
    })
  },
  
  // 获取相似商品
  getSimilarProducts(productId, limit = 10) {
    return api.get('/recommendations', { 
      params: { product_id: productId, limit } 
    })
  }
}
```

## 样式设计规范

### 1. 颜色规范
```scss
// 主色调
$primary-color: #00ffff;
$secondary-color: #ff00ff;
$accent-color: #9C27B0;

// 背景色
$bg-primary: #0a0a0a;
$bg-secondary: rgba(255, 255, 255, 0.05);
$bg-modal: rgba(10, 10, 10, 0.95);

// 文字色
$text-primary: #ffffff;
$text-secondary: rgba(255, 255, 255, 0.7);
$text-muted: rgba(255, 255, 255, 0.5);

// 边框色
$border-primary: rgba(0, 255, 255, 0.2);
$border-secondary: rgba(0, 255, 255, 0.1);
```

### 2. 渐变效果
```scss
// 按钮渐变
.btn-primary {
  background: linear-gradient(45deg, #00ffff, #ff00ff);
}

.btn-secondary {
  background: linear-gradient(45deg, #ff6b6b, #ffa500);
}

.btn-accent {
  background: linear-gradient(45deg, #9C27B0, #E91E63);
}

// 背景渐变
.bg-animation {
  background: 
    radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
    radial-gradient(circle at 40% 80%, rgba(0, 255, 0, 0.1) 0%, transparent 50%);
}
```

### 3. 动画效果
```scss
// 背景动画
@keyframes backgroundMove {
  0%, 100% { transform: translateX(0) translateY(0); }
  25% { transform: translateX(-2%) translateY(-2%); }
  50% { transform: translateX(2%) translateY(-1%); }
  75% { transform: translateX(-1%) translateY(2%); }
}

// 悬停效果
.product-card:hover {
  transform: translateY(-5px);
  border-color: #00ffff;
  box-shadow: 0 15px 30px rgba(0, 255, 255, 0.2);
}

// 按钮效果
.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 25px rgba(0, 255, 255, 0.4);
}
```

## 响应式设计

### 1. 断点设置
```scss
// 响应式断点
$breakpoints: (
  mobile: 480px,
  tablet: 768px,
  desktop: 1024px,
  large: 1200px
);

// 媒体查询混入
@mixin mobile {
  @media (max-width: 480px) { @content; }
}

@mixin tablet {
  @media (max-width: 768px) { @content; }
}

@mixin desktop {
  @media (min-width: 1024px) { @content; }
}
```

### 2. 布局适配
```scss
// 商品网格响应式
.products-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 1.5rem;
  
  @include tablet {
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1rem;
  }
  
  @include mobile {
    grid-template-columns: 1fr;
  }
}

// 交互按钮响应式
.interaction-buttons {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.5rem;
  
  @include tablet {
    grid-template-columns: repeat(2, 1fr);
  }
  
  @include mobile {
    grid-template-columns: 1fr;
  }
}
```

## 错误处理机制

### 1. API错误处理
```javascript
// API拦截器
api.interceptors.response.use(
  response => {
    const { data } = response
    
    if (data.status === 'success') {
      return data
    } else {
      ElMessage.error(data.message || '请求失败')
      return Promise.reject(new Error(data.message || '请求失败'))
    }
  },
  error => {
    const message = error.response?.data?.message || error.message || '网络错误'
    ElMessage.error(message)
    return Promise.reject(error)
  }
)
```

### 2. 组件错误处理
```javascript
// 错误边界处理
const handleError = (error, context) => {
  console.error(`Error in ${context}:`, error)
  ElMessage.error('操作失败，请重试')
}

// 异步操作错误处理
const safeAsyncOperation = async (operation, errorMessage) => {
  try {
    return await operation()
  } catch (error) {
    console.error(errorMessage, error)
    ElMessage.error(errorMessage)
    return null
  }
}
```

## 性能优化策略

### 1. 组件优化
- 使用Vue 3 Composition API
- 合理使用computed和watch
- 避免不必要的重新渲染

### 2. 数据优化
- 使用模拟数据作为回退
- 实现数据缓存机制
- 优化API请求频率

### 3. 样式优化
- 使用CSS变量
- 优化动画性能
- 减少重绘和回流

## 测试策略

### 1. 单元测试
- 组件功能测试
- 工具函数测试
- API接口测试

### 2. 集成测试
- 用户交互流程测试
- 推荐功能测试
- 历史记录测试

### 3. 端到端测试
- 完整用户流程测试
- 多端兼容性测试
- 性能测试
