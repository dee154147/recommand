# 相似商品查询详细设计文档

## 文档信息
- **项目名称**: 智能推荐系统
- **模块名称**: 相似商品查询
- **文档版本**: v1.0
- **创建日期**: 2024年12月20日
- **最后更新**: 2024年12月20日

## 1. 系统架构设计

### 1.1 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端界面      │    │   后端服务      │    │   数据库层      │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │商品检索页面 │ │◄──►│ │Flask API   │ │◄──►│ │PostgreSQL   │ │
│ │相似商品弹窗 │ │    │ │推荐服务     │ │    │ │pgvector     │ │
│ │用户交互     │ │    │ │向量计算     │ │    │ │Redis缓存    │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 技术栈
- **前端**: Vue.js 3 + Element Plus
- **后端**: Python Flask + SQLAlchemy
- **数据库**: PostgreSQL 12+ + pgvector
- **缓存**: Redis 6+
- **向量模型**: Tencent AILab Chinese Embedding

## 2. 核心模块设计

### 2.1 相似商品服务模块

#### 2.1.1 SimilarProductService 类
```python
class SimilarProductService:
    """相似商品查询服务"""
    
    def __init__(self, db_session, cache_client, vector_model):
        self.db = db_session
        self.cache = cache_client
        self.vector_model = vector_model
    
    def find_similar_products(self, product_id, user_id=None, limit=12, threshold=0.75):
        """
        查找相似商品
        
        Args:
            product_id: 目标商品ID
            user_id: 用户ID（可选，用于个性化推荐）
            limit: 返回商品数量
            threshold: 相似度阈值
            
        Returns:
            List[dict]: 相似商品列表
        """
        pass
    
    def calculate_similarity(self, product1_id, product2_id):
        """计算两个商品的相似度"""
        pass
    
    def precompute_similarities(self, batch_size=100):
        """批量预计算商品相似度"""
        pass
    
    def update_product_vector(self, product_id):
        """更新商品向量嵌入"""
        pass
```

#### 2.1.2 向量计算模块
```python
class VectorCalculator:
    """向量计算模块"""
    
    def __init__(self, model_path):
        self.model = self._load_model(model_path)
    
    def _load_model(self, model_path):
        """加载预训练模型"""
        pass
    
    def generate_embedding(self, text):
        """生成文本向量嵌入"""
        pass
    
    def calculate_cosine_similarity(self, vec1, vec2):
        """计算余弦相似度"""
        pass
    
    def batch_generate_embeddings(self, texts):
        """批量生成向量嵌入"""
        pass
```

### 2.2 API接口模块

#### 2.2.1 相似商品查询接口
```python
@api.route('/api/similar-products/<int:product_id>', methods=['GET'])
def get_similar_products(product_id):
    """
    获取相似商品
    
    Query Parameters:
        limit: 返回数量 (默认12)
        threshold: 相似度阈值 (默认0.75)
        user_id: 用户ID (可选)
    
    Returns:
        JSON: 相似商品列表
    """
    try:
        # 参数验证
        limit = request.args.get('limit', 12, type=int)
        threshold = request.args.get('threshold', 0.75, type=float)
        user_id = request.args.get('user_id', type=int)
        
        # 参数范围检查
        if not (1 <= limit <= 20):
            return jsonify({'error': 'limit must be between 1 and 20'}), 400
        if not (0.0 <= threshold <= 1.0):
            return jsonify({'error': 'threshold must be between 0.0 and 1.0'}), 400
        
        # 查询相似商品
        similar_service = SimilarProductService(db.session, cache, vector_model)
        similar_products = similar_service.find_similar_products(
            product_id=product_id,
            user_id=user_id,
            limit=limit,
            threshold=threshold
        )
        
        # 记录查询日志
        log_query(product_id, user_id, len(similar_products))
        
        return jsonify({
            'success': True,
            'data': similar_products,
            'meta': {
                'product_id': product_id,
                'count': len(similar_products),
                'threshold': threshold
            }
        })
        
    except Exception as e:
        logger.error(f"Error getting similar products: {str(e)}")
        return jsonify({'error': 'Internal server error'}), 500
```

#### 2.2.2 商品向量更新接口
```python
@api.route('/api/products/<int:product_id>/vector', methods=['POST'])
def update_product_vector(product_id):
    """更新商品向量嵌入"""
    try:
        # 获取商品信息
        product = Product.query.get(product_id)
        if not product:
            return jsonify({'error': 'Product not found'}), 404
        
        # 更新向量
        similar_service = SimilarProductService(db.session, cache, vector_model)
        similar_service.update_product_vector(product_id)
        
        return jsonify({'success': True, 'message': 'Vector updated successfully'})
        
    except Exception as e:
        logger.error(f"Error updating product vector: {str(e)}")
        return jsonify({'error': 'Internal server error'}), 500
```

### 2.3 前端组件设计

#### 2.3.1 相似商品弹窗组件
```vue
<template>
  <el-dialog
    v-model="visible"
    title="相似商品推荐"
    width="80%"
    :before-close="handleClose"
    class="similar-products-dialog"
  >
    <!-- 参考商品信息 -->
    <div class="reference-product">
      <h3>参考商品</h3>
      <div class="product-info">
        <img :src="referenceProduct.image_url" :alt="referenceProduct.name" />
        <div class="product-details">
          <h4>{{ referenceProduct.name }}</h4>
          <p class="price">¥{{ referenceProduct.price }}</p>
        </div>
      </div>
    </div>
    
    <!-- 相似商品网格 -->
    <div class="similar-products-grid">
      <div
        v-for="product in similarProducts"
        :key="product.id"
        class="product-card"
        @click="selectProduct(product)"
      >
        <img :src="product.image_url" :alt="product.name" />
        <h4>{{ product.name }}</h4>
        <p class="price">¥{{ product.price }}</p>
        <div class="similarity-score">
          相似度: {{ (product.similarity_score * 100).toFixed(1) }}%
        </div>
      </div>
    </div>
    
    <!-- 操作按钮 -->
    <template #footer>
      <el-button @click="handleClose">关闭</el-button>
      <el-button type="primary" @click="refreshRecommendations">刷新推荐</el-button>
    </template>
  </el-dialog>
</template>

<script>
export default {
  name: 'SimilarProductsDialog',
  props: {
    productId: {
      type: Number,
      required: true
    },
    visible: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      referenceProduct: {},
      similarProducts: [],
      loading: false
    }
  },
  watch: {
    visible(newVal) {
      if (newVal) {
        this.loadSimilarProducts()
      }
    }
  },
  methods: {
    async loadSimilarProducts() {
      this.loading = true
      try {
        const response = await this.$api.getSimilarProducts(this.productId)
        this.referenceProduct = response.data.reference_product
        this.similarProducts = response.data.similar_products
      } catch (error) {
        this.$message.error('加载相似商品失败')
        console.error('Error loading similar products:', error)
      } finally {
        this.loading = false
      }
    },
    
    selectProduct(product) {
      this.$emit('product-selected', product)
      this.handleClose()
    },
    
    refreshRecommendations() {
      this.loadSimilarProducts()
    },
    
    handleClose() {
      this.$emit('update:visible', false)
    }
  }
}
</script>
```

#### 2.3.2 商品卡片组件增强
```vue
<template>
  <div class="product-card">
    <!-- 商品图片 -->
    <div class="product-image">
      <img :src="product.image_url" :alt="product.name" />
    </div>
    
    <!-- 商品信息 -->
    <div class="product-info">
      <div class="product-details">
        <h3 class="product-name">{{ product.name }}</h3>
        <p class="product-description">{{ product.description }}</p>
        <div class="product-price">¥{{ product.price }}</div>
        <div class="product-tags">
          <span v-for="tag in product.tags" :key="tag" class="product-tag">
            {{ tag }}
          </span>
        </div>
      </div>
      
      <!-- 相似商品按钮 -->
      <button 
        class="similar-btn" 
        @click="showSimilarProducts"
        :disabled="loading"
      >
        <i class="el-icon-search"></i>
        {{ loading ? '查找中...' : '查找相似商品' }}
      </button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'ProductCard',
  props: {
    product: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      loading: false
    }
  },
  methods: {
    showSimilarProducts() {
      this.$emit('show-similar-products', this.product.id)
    }
  }
}
</script>
```

## 3. 算法设计

### 3.1 相似度计算算法

#### 3.1.1 文本向量化
```python
def generate_product_embedding(product):
    """
    生成商品向量嵌入
    
    Args:
        product: 商品对象
        
    Returns:
        numpy.ndarray: 384维向量
    """
    # 组合商品文本信息
    text_parts = [
        product.name,
        product.description or '',
        ' '.join(product.tags or []),
        product.brand or ''
    ]
    
    # 拼接文本
    combined_text = ' '.join(filter(None, text_parts))
    
    # 生成向量嵌入
    embedding = vector_model.generate_embedding(combined_text)
    
    return embedding
```

#### 3.1.2 相似度计算
```python
def calculate_similarity_score(vec1, vec2):
    """
    计算两个向量的余弦相似度
    
    Args:
        vec1: 向量1
        vec2: 向量2
        
    Returns:
        float: 相似度分数 (0-1)
    """
    # 计算余弦相似度
    dot_product = np.dot(vec1, vec2)
    norm1 = np.linalg.norm(vec1)
    norm2 = np.linalg.norm(vec2)
    
    if norm1 == 0 or norm2 == 0:
        return 0.0
    
    similarity = dot_product / (norm1 * norm2)
    return max(0.0, similarity)  # 确保非负
```

### 3.2 推荐算法

#### 3.2.1 基础推荐算法
```python
def basic_similarity_recommendation(product_id, limit=12, threshold=0.75):
    """
    基础相似度推荐
    
    Args:
        product_id: 目标商品ID
        limit: 推荐数量
        threshold: 相似度阈值
        
    Returns:
        List[dict]: 推荐商品列表
    """
    # 获取目标商品向量
    target_product = Product.query.get(product_id)
    if not target_product or not target_product.vector_embedding:
        return []
    
    target_vector = np.array(target_product.vector_embedding)
    
    # 查询相似商品
    similar_products = db.session.query(Product).filter(
        Product.id != product_id,
        Product.status == 'active',
        Product.vector_embedding.isnot(None)
    ).all()
    
    # 计算相似度并排序
    similarities = []
    for product in similar_products:
        similarity = calculate_similarity_score(
            target_vector, 
            np.array(product.vector_embedding)
        )
        
        if similarity >= threshold:
            similarities.append({
                'product': product,
                'similarity': similarity
            })
    
    # 按相似度排序
    similarities.sort(key=lambda x: x['similarity'], reverse=True)
    
    # 返回top-N结果
    return similarities[:limit]
```

#### 3.2.2 个性化推荐算法
```python
def personalized_similarity_recommendation(product_id, user_id, limit=12, threshold=0.75):
    """
    个性化相似度推荐
    
    Args:
        product_id: 目标商品ID
        user_id: 用户ID
        limit: 推荐数量
        threshold: 相似度阈值
        
    Returns:
        List[dict]: 推荐商品列表
    """
    # 获取基础推荐
    basic_recommendations = basic_similarity_recommendation(product_id, limit * 2, threshold)
    
    if not user_id:
        return basic_recommendations[:limit]
    
    # 获取用户偏好
    user_preferences = get_user_preferences(user_id)
    
    # 计算个性化分数
    personalized_recommendations = []
    for rec in basic_recommendations:
        product_id = rec['product'].id
        similarity_score = rec['similarity']
        
        # 用户偏好权重
        preference_weight = user_preferences.get(product_id, 0)
        
        # 综合分数 = 相似度 * 0.7 + 用户偏好 * 0.3
        personalized_score = similarity_score * 0.7 + preference_weight * 0.3
        
        personalized_recommendations.append({
            'product': rec['product'],
            'similarity': similarity_score,
            'personalized_score': personalized_score
        })
    
    # 按个性化分数排序
    personalized_recommendations.sort(key=lambda x: x['personalized_score'], reverse=True)
    
    return personalized_recommendations[:limit]
```

## 4. 性能优化设计

### 4.1 缓存策略

#### 4.1.1 Redis缓存设计
```python
class SimilarProductCache:
    """相似商品缓存管理"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
        self.cache_ttl = 3600  # 1小时
    
    def get_cache_key(self, product_id, user_id=None):
        """生成缓存键"""
        if user_id:
            return f"similar_products:{product_id}:user:{user_id}"
        return f"similar_products:{product_id}"
    
    def get_similar_products(self, product_id, user_id=None):
        """从缓存获取相似商品"""
        cache_key = self.get_cache_key(product_id, user_id)
        cached_data = self.redis.get(cache_key)
        
        if cached_data:
            return json.loads(cached_data)
        return None
    
    def set_similar_products(self, product_id, similar_products, user_id=None):
        """缓存相似商品"""
        cache_key = self.get_cache_key(product_id, user_id)
        self.redis.setex(
            cache_key, 
            self.cache_ttl, 
            json.dumps(similar_products, default=str)
        )
    
    def invalidate_cache(self, product_id):
        """清除相关缓存"""
        pattern = f"similar_products:{product_id}*"
        keys = self.redis.keys(pattern)
        if keys:
            self.redis.delete(*keys)
```

#### 4.1.2 缓存更新策略
```python
def update_product_cache(product_id):
    """更新商品相关缓存"""
    cache = SimilarProductCache(redis_client)
    
    # 清除该商品的相似商品缓存
    cache.invalidate_cache(product_id)
    
    # 清除以该商品为相似商品的缓存
    similar_products = db.session.query(ProductSimilarity).filter(
        ProductSimilarity.similar_product_id == product_id
    ).all()
    
    for sp in similar_products:
        cache.invalidate_cache(sp.product_id)
```

### 4.2 数据库优化

#### 4.2.1 查询优化
```python
def optimized_similarity_query(product_id, limit=12, threshold=0.75):
    """优化的相似度查询"""
    # 使用预计算相似度表
    query = db.session.query(
        ProductSimilarity.similar_product_id,
        ProductSimilarity.similarity_score,
        Product.id,
        Product.name,
        Product.price,
        Product.image_url
    ).join(
        Product, ProductSimilarity.similar_product_id == Product.id
    ).filter(
        ProductSimilarity.product_id == product_id,
        ProductSimilarity.similarity_score >= threshold,
        Product.status == 'active'
    ).order_by(
        ProductSimilarity.similarity_score.desc()
    ).limit(limit)
    
    return query.all()
```

#### 4.2.2 批量处理
```python
def batch_update_vectors(batch_size=100):
    """批量更新商品向量"""
    products = Product.query.filter(
        Product.status == 'active',
        Product.vector_embedding.is_(None)
    ).limit(batch_size).all()
    
    for product in products:
        try:
            # 生成向量
            embedding = generate_product_embedding(product)
            
            # 更新数据库
            product.vector_embedding = embedding.tolist()
            db.session.commit()
            
        except Exception as e:
            logger.error(f"Error updating vector for product {product.id}: {str(e)}")
            db.session.rollback()
```

## 5. 错误处理设计

### 5.1 异常处理策略
```python
class SimilarProductError(Exception):
    """相似商品查询异常基类"""
    pass

class ProductNotFoundError(SimilarProductError):
    """商品不存在异常"""
    pass

class VectorCalculationError(SimilarProductError):
    """向量计算异常"""
    pass

class DatabaseError(SimilarProductError):
    """数据库异常"""
    pass

def handle_similar_product_query(product_id, user_id=None, limit=12):
    """处理相似商品查询的异常"""
    try:
        # 验证商品存在
        product = Product.query.get(product_id)
        if not product:
            raise ProductNotFoundError(f"Product {product_id} not found")
        
        # 检查商品状态
        if product.status != 'active':
            raise ProductNotFoundError(f"Product {product_id} is not active")
        
        # 检查向量是否存在
        if not product.vector_embedding:
            raise VectorCalculationError(f"Product {product_id} has no vector embedding")
        
        # 执行查询
        return find_similar_products(product_id, user_id, limit)
        
    except ProductNotFoundError:
        return {'error': 'Product not found', 'code': 404}
    except VectorCalculationError:
        return {'error': 'Vector calculation failed', 'code': 500}
    except DatabaseError:
        return {'error': 'Database error', 'code': 500}
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return {'error': 'Internal server error', 'code': 500}
```

### 5.2 降级策略
```python
def fallback_recommendation(product_id, limit=12):
    """降级推荐策略"""
    try:
        # 尝试基于分类的推荐
        product = Product.query.get(product_id)
        if product and product.category_id:
            similar_by_category = Product.query.filter(
                Product.category_id == product.category_id,
                Product.id != product_id,
                Product.status == 'active'
            ).limit(limit).all()
            
            return [{
                'product': p,
                'similarity': 0.5,  # 默认相似度
                'method': 'category_fallback'
            } for p in similar_by_category]
        
        # 最后降级：随机推荐
        random_products = Product.query.filter(
            Product.id != product_id,
            Product.status == 'active'
        ).order_by(func.random()).limit(limit).all()
        
        return [{
            'product': p,
            'similarity': 0.3,  # 较低相似度
            'method': 'random_fallback'
        } for p in random_products]
        
    except Exception as e:
        logger.error(f"Fallback recommendation failed: {str(e)}")
        return []
```

## 6. 监控和日志设计

### 6.1 性能监控
```python
import time
from functools import wraps

def monitor_performance(func):
    """性能监控装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            
            # 记录性能指标
            logger.info(f"{func.__name__} executed in {execution_time:.3f}s")
            
            # 如果执行时间过长，记录警告
            if execution_time > 2.0:
                logger.warning(f"{func.__name__} took {execution_time:.3f}s (slow)")
            
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"{func.__name__} failed after {execution_time:.3f}s: {str(e)}")
            raise
    
    return wrapper
```

### 6.2 业务日志
```python
def log_similarity_query(product_id, user_id, result_count, response_time):
    """记录相似商品查询日志"""
    log_entry = {
        'event': 'similarity_query',
        'product_id': product_id,
        'user_id': user_id,
        'result_count': result_count,
        'response_time_ms': int(response_time * 1000),
        'timestamp': datetime.utcnow().isoformat()
    }
    
    logger.info(json.dumps(log_entry))
    
    # 存储到数据库
    query_log = SimilarityQueryLog(
        user_id=user_id,
        query_product_id=product_id,
        result_count=result_count,
        response_time_ms=int(response_time * 1000)
    )
    
    db.session.add(query_log)
    db.session.commit()
```

## 7. 测试设计

### 7.1 单元测试
```python
import unittest
from unittest.mock import Mock, patch

class TestSimilarProductService(unittest.TestCase):
    """相似商品服务测试"""
    
    def setUp(self):
        self.mock_db = Mock()
        self.mock_cache = Mock()
        self.mock_vector_model = Mock()
        self.service = SimilarProductService(
            self.mock_db, self.mock_cache, self.mock_vector_model
        )
    
    def test_find_similar_products_success(self):
        """测试成功查找相似商品"""
        # 模拟数据
        mock_product = Mock()
        mock_product.id = 1
        mock_product.vector_embedding = [0.1] * 384
        
        self.mock_db.query.return_value.get.return_value = mock_product
        
        # 执行测试
        result = self.service.find_similar_products(1)
        
        # 验证结果
        self.assertIsInstance(result, list)
    
    def test_find_similar_products_not_found(self):
        """测试商品不存在的情况"""
        self.mock_db.query.return_value.get.return_value = None
        
        result = self.service.find_similar_products(999)
        
        self.assertEqual(result, [])
    
    def test_calculate_similarity(self):
        """测试相似度计算"""
        vec1 = [1, 0, 0]
        vec2 = [1, 0, 0]
        
        similarity = self.service.calculate_similarity(1, 2)
        
        self.assertAlmostEqual(similarity, 1.0, places=3)
```

### 7.2 集成测试
```python
class TestSimilarProductAPI(unittest.TestCase):
    """相似商品API集成测试"""
    
    def setUp(self):
        self.app = create_app()
        self.client = self.app.test_client()
        self.app_context = self.app.app_context()
        self.app_context.push()
    
    def tearDown(self):
        self.app_context.pop()
    
    def test_get_similar_products_success(self):
        """测试获取相似商品API成功"""
        response = self.client.get('/api/similar-products/1')
        
        self.assertEqual(response.status_code, 200)
        data = response.get_json()
        self.assertTrue(data['success'])
        self.assertIn('data', data)
    
    def test_get_similar_products_not_found(self):
        """测试商品不存在的情况"""
        response = self.client.get('/api/similar-products/999')
        
        self.assertEqual(response.status_code, 404)
```

## 8. 部署设计

### 8.1 Docker配置
```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["python", "run.py"]
```

### 8.2 环境配置
```python
# config.py
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'postgresql://user:pass@localhost/recommendation'
    REDIS_URL = os.environ.get('REDIS_URL') or 'redis://localhost:6379/0'
    
    # 相似商品配置
    SIMILAR_PRODUCTS_LIMIT = int(os.environ.get('SIMILAR_PRODUCTS_LIMIT', 12))
    SIMILARITY_THRESHOLD = float(os.environ.get('SIMILARITY_THRESHOLD', 0.75))
    VECTOR_MODEL_PATH = os.environ.get('VECTOR_MODEL_PATH', '/app/model/')
    
    # 缓存配置
    CACHE_TTL = int(os.environ.get('CACHE_TTL', 3600))
```

## 9. 附录

### 9.1 相关文件
- 需求文档
- 数据库设计文档
- API接口文档
- 系统架构文档

### 9.2 开发工具
- 代码编辑器: VS Code
- 版本控制: Git
- 测试框架: pytest
- 文档生成: Sphinx
