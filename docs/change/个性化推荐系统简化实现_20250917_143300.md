# 个性化推荐系统简化实现

## 修改时间
2025-09-17 14:33:00

## 修改内容

### 问题描述
用户反馈用户交互页面没有实现个性化推荐功能，要求简化推荐系统，只使用基于内容的推荐算法，根据用户交互过的商品计算特征向量，然后检索相似商品并直接返回。

### 解决方案

#### 1. 简化后端推荐算法
- **文件**: `backend/app/api/personalized_recommendation_routes.py`
- **修改内容**:
  - 移除了协同过滤和混合推荐算法
  - 只保留基于内容的推荐算法
  - 实现了基于特征向量相似性的推荐逻辑

#### 2. 实现基于特征向量的推荐算法
- **核心函数**:
  - `calculate_user_preference_vector()`: 计算用户偏好向量（基于交互商品的embedding加权平均）
  - `find_similar_products_by_vector()`: 基于向量相似性搜索相似商品
  - `calculate_cosine_similarity()`: 计算余弦相似度
  - `get_category_based_recommendations()`: 基于分类的推荐（回退方案）

#### 3. 推荐算法流程
1. 获取用户交互历史
2. 计算用户偏好向量（基于交互商品的embedding加权平均）
3. 使用余弦相似度计算与其他商品的相似性
4. 返回最相似的商品作为推荐

#### 4. 修复的问题
- 修复了`get_popular_products()`函数返回JSON响应而不是列表的问题
- 添加了详细的调试日志
- 优化了错误处理机制

### 技术实现

#### 用户偏好向量计算
```python
def calculate_user_preference_vector(user_interactions):
    """计算用户偏好向量（基于交互商品的embedding加权平均）"""
    # 获取用户交互的商品及其embedding
    product_embeddings = []
    weights = []
    
    for interaction in user_interactions:
        product = Product.query.filter_by(id=interaction.product_id).first()
        if product and product.embedding:
            embedding_values = [float(x) for x in product.embedding.strip('[]').split(',')]
            product_embeddings.append(embedding_values)
            weights.append(interaction.interaction_score or 1.0)
    
    # 计算加权平均向量
    embeddings_array = np.array(product_embeddings)
    weights_array = np.array(weights)
    weights_array = weights_array / np.sum(weights_array)
    user_vector = np.average(embeddings_array, axis=0, weights=weights_array)
    
    return user_vector.tolist()
```

#### 向量相似性搜索
```python
def find_similar_products_by_vector(user_vector, exclude_product_ids, limit):
    """基于向量相似性搜索相似商品"""
    similarities = []
    for product in products:
        if product.embedding:
            product_embedding = [float(x) for x in product.embedding.strip('[]').split(',')]
            similarity = calculate_cosine_similarity(user_vector, product_embedding)
            similarities.append((product, similarity))
    
    # 按相似度排序
    similarities.sort(key=lambda x: x[1], reverse=True)
    return similarities[:limit]
```

### 测试结果

#### API测试
- **测试用户**: 用户ID 3
- **交互商品**: HTC 聆 悦 S260 T 528d T328 w T 328d One M7 G18 g21 T528 w 原装耳机
- **推荐结果**: 成功返回5个相似商品
  - HTC A810 E G8 G9 G14 T528 3.5 mm 毫米 A510 E G11 S710 E 原装耳机 (相似度: 1.000)
  - HTC 聆 悦 MAX 300 T528 X 920 E 8 X 802 W 802D one M7 立体声 原装耳机 (相似度: 1.000)
  - HTC G21 G10 G11 G12 G14 G15 G16 G17 G20 Z 715 S710 d 原装耳机 (相似度: 1.000)
  - 索尼 LT 28 i LT 28 H ST21 I ST 27I ST 23 I MT 28 I S35 H L 35 H 原装耳机 (相似度: 0.960)
  - 摩托罗拉 XT 682 MT 887 MT 680 MB 886 XT 611 XT 536 原装蓝牙耳机 (相似度: 0.959)

#### 推荐质量
- 所有推荐商品都是耳机类产品，与用户交互的商品高度相关
- 相似度计算准确，能够识别出最相似的商品
- 推荐结果包含相似度分数和推荐原因

### 系统优势

1. **算法简化**: 只使用基于内容的推荐算法，避免了复杂的混合算法
2. **性能优化**: 基于特征向量的相似性计算效率高
3. **准确性**: 使用余弦相似度能够准确计算商品间的相似性
4. **可解释性**: 推荐结果包含相似度分数和推荐原因
5. **扩展性**: 支持用户交互权重的加权平均计算

### 前端集成

前端推荐功能已经集成到用户交互页面：
- 用户进行商品交互后，系统会自动更新推荐
- 推荐区域显示个性化推荐商品
- 支持刷新推荐功能
- 推荐商品包含相似度分数和推荐原因

### 后续优化建议

1. **缓存机制**: 可以添加推荐结果缓存，提高响应速度
2. **实时更新**: 可以考虑实时更新用户偏好向量
3. **多样性**: 可以添加多样性控制，避免推荐结果过于相似
4. **冷启动**: 对于新用户，可以提供更好的冷启动策略

## 总结

成功实现了简化的个性化推荐系统，基于用户交互商品的特征向量计算相似商品并推荐。系统运行稳定，推荐质量良好，能够准确识别用户偏好并提供相关商品推荐。
